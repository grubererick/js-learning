<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <title>JS Learning</title>
</head>

<body>
  <h1>
    JavaScript: The Advanced Concepts (2022 Update)
  </h1>
  <section>
    <h2>Javascript Foundation</h2>
    <p><u>Call Stack and Memory Heap</u></p>
    <p>
      The memory heap is where the memory allocation happens and the call stack is
      where the engine keeps track of where your code is in its execution.
    <p>
      Our
      memory heap is simply a free store, is a large region in memory that the
      JavaScript engine provides for us, which can be used to store any type of
      arbitrary data in an unordered fashion. There's no order to this memory.
    </p>
    <pre>
        <code>
        // call stack + Memory heap
        const number = 610; // allocate memory for nr.
        const string = 'some text'; // allocate memory for string
        const human = { // allocate memory for an objext ... and it's values
        firstName: 'Erick',
        lastName: 'Gruber'
        }
      </code>
      </pre>
    </p>
    <p>
      The call stack stores, functions and variables as your code executes at each entry state of the stack.
      Also called the stack frame.
      That is the first one in is the last one getting popped out.
      And we can keep adding keep adding to the stack and eventually it pops, pops, pops all the function
      calls until we are done with our commands.
      And we use the memory heap to actually point to different variables and objects and data that we store
      so that we know where to look.
      <br>
      <picture>
        <img src="./pictures/CallsStackandMemoryHeap_2.png" alt="">
      </picture>
    </p>
    <p><u>Stack overflow</u></p>
    <pre>
      <code>
        // Stack
      function inception() {
         inception()
      }

      inception()
      </code>
    </pre>
    <p><u>Garbage Colletion</u></p>
    We have to understand this concept of garbage collection.
    JavaScript is a garbage collected language.
    That means when JavaScript allocates memory, let's say within a function, we create an object and
    that object gets stored somewhere in our memory heap automatically with JavaScript.
    When we finish calling the function and let's say we don't need that object anymore, it's going to
    clean it up for us.
    So only the data that is still useful to us remains so that this way we make sure we don't use up all the memory we
    have available because as we know, memory is limited.
    <p>Now in garbage collected languages like JavaScript, the garbage collector frees memory on the heap
      and prevents what we call memory leaks.
      That is when the memory gets too big, too big until we reach our maximum size.</p>
    <p>it uses something called Mark and sweep algorithm.</p>
    <p><u>Memory Leaks</u></p>
    <p>
      when I run this code, what's going to happen is we're going to run an infinite loop that keeps
    </p>
    <pre>
        <code>
          let array = [];
          for (let i = 5; i > 1; i++) {
          array.push(i - 1);
          }
        </code>
      </pre>
    <pre>
        <code>
          //Memory leak

        // Global leak
        var a = 1;
        var b = 1;
        var b = 1;

        // Event listeners
        /*This happens a lot, especially if you go back and forth between single page applications where you're not removing the event listeners off the page.*/
        let elemnt = document.getElementById('button');
        element.addEventListener('click', onclick)

        //setInterval
        setInterval(() => {
        // refereing onjetcts
        /*You start referencing objects.And these objects in here are going to, well, never be collected by the garbage collector, because this set interval, unless we clear it and stop it, is going to keep running and running and running.*/
})
        </code>
      </pre>
    <p><u>Single Threaded</u></p>
      
  </section>
</body>

</html>